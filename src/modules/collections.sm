<-string.join,wrap;
<-iter.find;

@ Stack {

    create size:-/ * {
        'stack: [];
        'size: size;
    }

    push item * {
        ? 'isFull() { "stack is full (size " + 'size.toString() + ")"!!!; }
        'stack+: [item];
    }

    pushAll item * { ... element ->? item { 'push(element); } }

    special * { * 'stack$; }

    pop * {
        ? 'isEmpty() { "stack is empty"!!!; }
        out: 'stack<<-/>>;
        'stack-: 'stack$ - /;
        * out;
    }

    peek * {
        ? 'isEmpty() { "stack is empty"!!!; }
        * 'stack<<-/>>;
    }

    toBoolean * { * 'stack$ > \; }

    isFull * { * 'size :: 'stack$; }

    isEmpty * { * 'stack$ :: \; }

    toString * {
        ?? { top: 'peek(); }
        !! { top: _; }
        ? top?! :: "String" { top: wrap(top.toString(), "\""); }
        * "Stack(capacity:" + 'size.toString()
        + ", size:" + 'stack$.toString()
        + ", top:" + top.toString()
        + ")";
    }
}

@ Queue {

    create size:-/ * {
        'queue: [];
        'size: size;
    }

    special * { * 'queue$; }
    isEmpty * { * '$ :: \; }
    isFull * { * '$ :: 'size; }

    throwEmpty * { ? 'isEmpty() { "queue is empty"!!!; } }

    put item * {
        ? 'isFull() { "queue is full (size " + 'size.toString() + ")"!!!; }
        'queue+: [item];
    }

    putAll items * {
        ... item ->? items { 'put(item); }
    }

    get * {
        'throwEmpty();
        out: 'queue<<\>>;
        'queue-: \;
        * out;
    }

    first * { 'throwEmpty(); * 'queue<<\>>; }
    last * { 'throwEmpty(); * 'queue<<-/>>; }

    toString * {
        ? '$ <: /\/ {
            items: 'queue.toString();
        } ,, ? '$ > /\/ {
            first: 'first().toString();
            last: 'last().toString();
            ? first?! :: "String" { first: wrap(first, "\""); }
            ? last?! :: "String" { last: wrap(last, "\""); }
            items: "[" + first.toString() + ", ..., " + last.toString() + "]";
        } ,, {
            items: "[]";
        }
        * "Queue(capacity:" + 'size.toString()
        + ", size:" + 'queue$.toString()
        + ", items:" + items + ")";
    }
}

@ Set {

    create items:[] capacity:-/ * {
        'items: [i ... i ->? items] ? items ,, [];
        'capacity: capacity;
    }

    special * { * 'items$; }

    add value * {
        ? ~~ 'has(value) {
            ? 'isFull() {
                "set is full (capacity " + 'capacity.toString() + ")"!!!;
            }
            'items+: [value];
            * /;
        }
        * \;
    }

    toBit * { * ~~ 'isEmpty(); }

    toString * {
        * "Set(capacity:" + 'capacity.toString()
        + ", size:" + '$.toString()
        + ", items:" + 'items.toString()
        + ")";
    }

    remove value * {
        idx: find('items, value);
        ? idx < \ { * _; }
        popped: 'items - idx;
        * popped;
    }

    has value * { * find('items, value) >: \; }

    values * { * 'items; }

    clear * { 'items: []; }

    isEmpty * { * '$ :: \; }

    isFull * { * '$ :: 'capacity; }

    newSetSize a b * { * a$ ? a$ > b$ ,, b$; }

    union other * {
        ? other?! ::: "Set" {
            "expected Set, received " + other?!!!!;
        }

        unionSet: Set('values(), 'newSetSize(', other) ++ /\);

        ... value ->? other.values() {
            unionSet.add(value);
        }

        * unionSet;
    }

    intersection other * {
        ? other?! ::: "Set" {
            "expected Set, received " + other?!!!!;
        }

        intersectionSet: Set(size: 'newSetSize(', other));

        ... value ->? 'values() {
            ? other.has(value) {
                intersectionSet.add(value);
            }
        }

        * intersectionSet;
    }

    difference other * {
        ? other?! ::: "Set" {
            "expected Set, received " + other?!!!!;
        }

        differenceSet: Set(capacity: 'newSetSize(', other));

        ... value ->? 'values() {
            ? ~~ other.has(value) {
                differenceSet.add(value);
            }
        }

        * differenceSet;
    }

    isSubset other * {
        ? other?! ::: "Set" {
            "expected Set, received " + other?!!!!;
        }

        ? '$ > other$ { * \; }

        ... value ->? 'values() {
            ? ~~ other.has(value) { * \; }
        }
        * /;
    }
}